<?php

namespace StonFi\Tests\contracts\dex\v2;

use Brick\Math\BigInteger;
use Brick\Math\Exception\DivisionByZeroException;
use Brick\Math\Exception\NumberFormatException;
use Olifanton\Interop\Address;
use Olifanton\Interop\Boc\Cell;
use Olifanton\Interop\Boc\Exceptions\BitStringException;
use Olifanton\Interop\Boc\Exceptions\CellException;
use Olifanton\Interop\Bytes;
use StonFi\const\v2\gas\provide\LpJettonGas;
use StonFi\const\v2\gas\provide\LpTonGas;
use StonFi\contracts\common\CallContractMethods;
use PHPUnit\Framework\TestCase;
use StonFi\contracts\dex\v2\ProvideLiquidityV2;
use StonFi\enums\Networks;
use StonFi\Init;
use StonFi\pTON\v1\PtonV1;
const USER_WALLET_ADDRESS = "UQAQnxLqlX2B6w4jQzzzPWA8eyWZVZBz6Y0D_8noARLOaEAn";
const ROUTER_ADDRESS = "kQCas2p939ESyXM_BzFJzcIe3GD5S0tbjJDj6EBVn-SPsEkN";
const OFFER_JETTON_ADDRESS = "kQDLvsZol3juZyOAVG8tWsJntOxeEZWEaWCbbSjYakQpuYN5"; // TestRED
const ASK_JETTON_ADDRESS = "kQB_TOJSB7q3-Jm1O8s0jKFtqLElZDPjATs5uJGsujcjznq3"; // TestBLUE

class ProvideLiquidityV2Test extends TestCase
{
    public Init $init;
    public ProvideLiquidityV2 $provideLiquidity;

    public $proxyTon;
    private function generateProviderMock()
    {
        $mock = $this->createMock(CallContractMethods::class);
        $mock->expects($this->any())
            ->method("getWalletAddress")
            ->willReturnCallback(function ($userAddr, $jettonAddr) {
                if ((new Address($jettonAddr))->isEqual(new Address(OFFER_JETTON_ADDRESS)))
                    return Cell::oneFromBoc("te6ccsEBAQEAJAAAAEOACD+9EGh6wT/2pEbZWrfCmVbsdpQVGU9308qh2gel9QwQM97q5A==", true)->beginParse()->loadAddress();

                if ((new Address($jettonAddr))->isEqual(new Address(ASK_JETTON_ADDRESS)))
                    return Cell::oneFromBoc("te6ccsEBAQEAJAAAAEOAAQDOYNkjxevc0Ludmj5oWQzsz/S9vn9/b/V0DLdsOUWw40LsPA==", true)->beginParse()->loadAddress();

                if ((new Address($jettonAddr))->isEqual($this->proxyTon->address))
                    return Cell::oneFromBoc("te6ccsEBAQEAJAAAAEOAAioWoxZMTVqjEz8xEP8QSW4AyorIq+/8UCfgJNM0gMPwJB4oTQ==", true)->beginParse()->loadAddress();

                throw new \Exception("Unexpected call: $userAddr");
            });
        return $mock;
    }
    protected function setUp(): void
    {
        $this->init = new Init(Networks::MAINNET);
        $this->init->setRouter(new Address(ROUTER_ADDRESS));
        $this->proxyTon = new PtonV1($this->init, new Address("kQAcOvXSnnOhCdLYc6up2ECYwtNNTzlmOlidBeCs5cFPV7AM"));
        $this->provideLiquidity = new ProvideLiquidityV2($this->init, provider: $this->generateProviderMock());
        parent::setUp(); // TODO: Change the autogenerated stub
    }

    public function testGas()
    {
        $this->assertEquals("235000000", (new LpJettonGas())->forwardGasAmount, 'LpJettonGas');
        $this->assertEquals("300000000", (new LpJettonGas())->gasAmount, 'LpJettonGas');
        $this->assertEquals("300000000", (new LpTonGas())->forwardGasAmount, 'LpTonGas');
    }

    public function testCreateProvideLiquidityBody()
    {
        $routerWalletAddress = new Address("EQAIBnMGyR4vXuaF3OzR80LIZ2Z_pe3z-_t_q6Blu2HKLeaY");
        $minLpOut = BigInteger::of(900000000);
        $receiverAddress = new Address(USER_WALLET_ADDRESS);
        $refundAddress = new Address(USER_WALLET_ADDRESS);
        $bothPositive = true;

        $result = $this->provideLiquidity->createProvideLiquidityBody(
            routerWalletAddress: $routerWalletAddress,
            minLpOut: $minLpOut,
            receiverAddress: $receiverAddress,
            refundAddress: $refundAddress,
            bothPositive: $bothPositive
        );
        $this->assertEquals(
            "te6cckEBAgEAlQAB0fz55Y+AAQDOYNkjxevc0Ludmj5oWQzsz/S9vn9/b/V0DLdsOUWwAEJ8S6pV9gesOI0M88z1gPHslmVWQc+mNA//J6AESzmiAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QAEATUNaTpAIACE+JdUq+wPWHEaGeeZ6wHj2SzKrIOfTGgf/k9ACJZzRBOPMRyY=",
            Bytes::bytesToBase64($result->toBoc(false))
        );
    }

    /**
     * @throws CellException
     * @throws DivisionByZeroException
     * @throws NumberFormatException
     * @throws BitStringException
     */
    public function testCreateCrossProvideLiquidityBody()
    {
        $routerWalletAddress = new Address("EQAIBnMGyR4vXuaF3OzR80LIZ2Z_pe3z-_t_q6Blu2HKLeaY");
        $minLpOut = BigInteger::of(900000000);
        $receiverAddress = new Address(USER_WALLET_ADDRESS);
        $refundAddress = new Address(USER_WALLET_ADDRESS);
        $bothPositive = true;

        $result = $this->provideLiquidity->createCrossProvideLiquidityBody(
            routerWalletAddress: $routerWalletAddress,
            minLpOut: $minLpOut,
            receiverAddress: $receiverAddress,
            refundAddress: $refundAddress,
            bothPositive: $bothPositive
        );
        $this->assertEquals(
            "te6cckEBAgEAlQAB0f///v+AAQDOYNkjxevc0Ludmj5oWQzsz/S9vn9/b/V0DLdsOUWwAEJ8S6pV9gesOI0M88z1gPHslmVWQc+mNA//J6AESzmiAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QAEATUNaTpAIACE+JdUq+wPWHEaGeeZ6wHj2SzKrIOfTGgf/k9ACJZzRBP2Nz5Y=",
            Bytes::bytesToBase64($result->toBoc(false))
        );
    }

    public function testGetProvideLiquidityJettonTxParams()
    {
        $userWalletAddress = new Address(USER_WALLET_ADDRESS);
        $sendTokenAddress = new Address(OFFER_JETTON_ADDRESS);
        $otherTokenAddress = new Address(ASK_JETTON_ADDRESS);
        $sendAmount = BigInteger::of("500000000");
        $minLpOut = BigInteger::of("1");

        $this->provideLiquidity = new ProvideLiquidityV2($this->init, provider: $this->generateProviderMock());

        // TEST 1 - should build expected tx params
        $result = $this->provideLiquidity->getProvideLiquidityJettonTxParams(
            userWalletAddress: $userWalletAddress,
            sendTokenAddress: $sendTokenAddress,
            otherTokenAddress: $otherTokenAddress,
            sendAmount: $sendAmount,
            minLpOut: $minLpOut
        );

        $this->assertEquals(
            "EQBB_eiDQ9YJ_7UiNsrVvhTKt2O0oKjKe76eVQ7QPS-oYPsi",
            $result->address->toString(true, true, true),
        );
        $this->assertEquals(
            "te6cckEBAwEA7QABsA+KfqUAAAAAAAAAAEHc1lAIATVm1Pu/oiWS5n4OYpObhD24wfKWlrcZIcfQgKs/yR9hAAQnxLqlX2B6w4jQzzzPWA8eyWZVZBz6Y0D/8noARLOaCBwDoYEBAdH8+eWPgAEAzmDZI8Xr3NC7nZo+aFkM7M/0vb5/f2/1dAy3bDlFsABCfEuqVfYHrDiNDPPM9YDx7JZlVkHPpjQP/yegBEs5ogAIT4l1Sr7A9YcRoZ55nrAePZLMqsg59MaB/+T0AIlnNEACAEcQGAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QSd6si5",
            $result->payload,
        );
        $this->assertEquals(
            BigInteger::of(300000000),
            $result->value
        );


        // TEST 2 - should build expected tx params when queryId is defined
        $result = $this->provideLiquidity->getProvideLiquidityJettonTxParams(
            userWalletAddress: $userWalletAddress,
            sendTokenAddress: $sendTokenAddress,
            otherTokenAddress: $otherTokenAddress,
            sendAmount: $sendAmount,
            minLpOut: $minLpOut,
            queryId: 12345
        );

        $this->assertEquals(
            "EQBB_eiDQ9YJ_7UiNsrVvhTKt2O0oKjKe76eVQ7QPS-oYPsi",
            $result->address->toString(true, true, true),
        );
        $this->assertEquals(
            "te6cckEBAwEA7QABsA+KfqUAAAAAAAAwOUHc1lAIATVm1Pu/oiWS5n4OYpObhD24wfKWlrcZIcfQgKs/yR9hAAQnxLqlX2B6w4jQzzzPWA8eyWZVZBz6Y0D/8noARLOaCBwDoYEBAdH8+eWPgAEAzmDZI8Xr3NC7nZo+aFkM7M/0vb5/f2/1dAy3bDlFsABCfEuqVfYHrDiNDPPM9YDx7JZlVkHPpjQP/yegBEs5ogAIT4l1Sr7A9YcRoZ55nrAePZLMqsg59MaB/+T0AIlnNEACAEcQGAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QTIC8jO",
            $result->payload,
        );
        $this->assertEquals(
            BigInteger::of(300000000),
            $result->value
        );

        // TEST 3 - should build expected tx params when queryId is defined
        $result = $this->provideLiquidity->getProvideLiquidityJettonTxParams(
            userWalletAddress: $userWalletAddress,
            sendTokenAddress: $sendTokenAddress,
            otherTokenAddress: $otherTokenAddress,
            sendAmount: $sendAmount,
            minLpOut: $minLpOut,
            gasAmount: BigInteger::of("1"),
            forwardGasAmount: BigInteger::of("2"),
        );

        $this->assertEquals(
            "EQBB_eiDQ9YJ_7UiNsrVvhTKt2O0oKjKe76eVQ7QPS-oYPsi",
            $result->address->toString(true, true, true),
        );
        $this->assertEquals(
            "te6cckEBAwEA6gABqg+KfqUAAAAAAAAAAEHc1lAIATVm1Pu/oiWS5n4OYpObhD24wfKWlrcZIcfQgKs/yR9hAAQnxLqlX2B6w4jQzzzPWA8eyWZVZBz6Y0D/8noARLOaAgUBAdH8+eWPgAEAzmDZI8Xr3NC7nZo+aFkM7M/0vb5/f2/1dAy3bDlFsABCfEuqVfYHrDiNDPPM9YDx7JZlVkHPpjQP/yegBEs5ogAIT4l1Sr7A9YcRoZ55nrAePZLMqsg59MaB/+T0AIlnNEACAEcQGAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QRCcylQ",
            $result->payload,
        );
        $this->assertEquals(
            BigInteger::of(1),
            $result->value
        );
    }

    public function testGetProvideLiquidityTonTxParams()
    {
        $userWalletAddress = new Address(USER_WALLET_ADDRESS);
        $otherTokenAddress = new Address(ASK_JETTON_ADDRESS);
        $proxyTon = new PtonV1($this->init, provider: $this->generateProviderMock());
        $this->proxyTon = $proxyTon;
        $sendAmount = BigInteger::of("500000000");
        $minLpOut = BigInteger::of("1");

        $this->provideLiquidity = new ProvideLiquidityV2($this->init, provider: $this->generateProviderMock());


        // TEST 1 - should build expected tx params
        $result = $this->provideLiquidity->getProvideLiquidityTonTxParams(
            userWalletAddress: $userWalletAddress,
            proxyTon: $proxyTon,
            otherTokenAddress: $otherTokenAddress,
            sendAmount: $sendAmount,
            minLpOut: $minLpOut,
        );

        $this->assertEquals(
            $result->address->isEqual(new Address("EQARULUYsmJq1RiZ-YiH-IJLcAZUVkVff-KBPwEmmaQGH6aC")),
            true
        );
        $this->assertEquals(
            "te6cckEBAwEAzAABbQ+KfqUAAAAAAAAAAEHc1lAIATVm1Pu/oiWS5n4OYpObhD24wfKWlrcZIcfQgKs/yR9gEEeGjAMBAdH8+eWPgAEAzmDZI8Xr3NC7nZo+aFkM7M/0vb5/f2/1dAy3bDlFsABCfEuqVfYHrDiNDPPM9YDx7JZlVkHPpjQP/yegBEs5ogAIT4l1Sr7A9YcRoZ55nrAePZLMqsg59MaB/+T0AIlnNEACAEcQGAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QSjBt/5",
            $result->payload
        );
        $this->assertEquals(
            BigInteger::of("800000000"),
            $result->value
        );


        // TEST 2 - should build expected tx params when queryId is defined
        $result = $this->provideLiquidity->getProvideLiquidityTonTxParams(
            userWalletAddress: $userWalletAddress,
            proxyTon: $proxyTon,
            otherTokenAddress: $otherTokenAddress,
            sendAmount: $sendAmount,
            minLpOut: $minLpOut,
            queryId: 12345
        );

        $this->assertEquals(
            $result->address->isEqual(new Address("EQARULUYsmJq1RiZ-YiH-IJLcAZUVkVff-KBPwEmmaQGH6aC")),
            true
        );
        $this->assertEquals(
            "te6cckEBAwEAzAABbQ+KfqUAAAAAAAAwOUHc1lAIATVm1Pu/oiWS5n4OYpObhD24wfKWlrcZIcfQgKs/yR9gEEeGjAMBAdH8+eWPgAEAzmDZI8Xr3NC7nZo+aFkM7M/0vb5/f2/1dAy3bDlFsABCfEuqVfYHrDiNDPPM9YDx7JZlVkHPpjQP/yegBEs5ogAIT4l1Sr7A9YcRoZ55nrAePZLMqsg59MaB/+T0AIlnNEACAEcQGAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QQFvZ1C",
            $result->payload
        );
        $this->assertEquals(
            BigInteger::of("800000000"),
            $result->value
        );


        // TEST 3 - should build expected tx params when custom gasAmount is defined
        $result = $this->provideLiquidity->getProvideLiquidityTonTxParams(
            userWalletAddress: $userWalletAddress,
            proxyTon: $proxyTon,
            otherTokenAddress: $otherTokenAddress,
            sendAmount: $sendAmount,
            minLpOut: $minLpOut,
            forwardGasAmount: BigInteger::of(2)
        );

        $this->assertTrue(
            $result->address->isEqual(new Address("EQARULUYsmJq1RiZ-YiH-IJLcAZUVkVff-KBPwEmmaQGH6aC"))
        );
        $this->assertEquals(
            "te6cckEBAwEAyQABZw+KfqUAAAAAAAAAAEHc1lAIATVm1Pu/oiWS5n4OYpObhD24wfKWlrcZIcfQgKs/yR9gBAsBAdH8+eWPgAEAzmDZI8Xr3NC7nZo+aFkM7M/0vb5/f2/1dAy3bDlFsABCfEuqVfYHrDiNDPPM9YDx7JZlVkHPpjQP/yegBEs5ogAIT4l1Sr7A9YcRoZ55nrAePZLMqsg59MaB/+T0AIlnNEACAEcQGAAhPiXVKvsD1hxGhnnmesB49ksyqyDn0xoH/5PQAiWc0QRKTjrp",
            $result->payload
        );
        $this->assertEquals(
            BigInteger::of("500000002"),
            $result->value
        );
    }
}
